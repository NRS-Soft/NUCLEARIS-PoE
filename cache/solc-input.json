{
  "language": "Solidity",
  "sources": {
    "src/contracts/NuclearPoE.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.11;\r\n\r\nimport './Process.sol';\r\nimport './Ownable.sol';\r\n\r\n/// @title Main Contract for Nuclearis Track\r\n/// @author Sebastian A. Martinez\r\n/// @notice This contract is the main entrypoint for the Nuclearistrack Platform\r\ncontract NuclearPoE is Ownable {\r\n    enum State {Null, Created, Closed}\r\n    enum Type {Admin, Client, Supplier}\r\n\r\n    struct Project {\r\n        State status;\r\n        address clientAddress;\r\n        string title;\r\n        string purchaseOrder;\r\n        address[] processContracts;\r\n    }\r\n    struct User {\r\n        State status;\r\n        Type userType;\r\n        string name;\r\n    }\r\n\r\n    address[] public processContractsArray;\r\n    address[] private _users;\r\n    uint256[] public projectsArray;\r\n\r\n    mapping(address => uint256[]) public projectsByAddress;\r\n    mapping(address => address[]) public processesByAddress;\r\n    mapping(address => User) private _user;\r\n    mapping(uint256 => Project) private _project;\r\n\r\n    event CreateProject(uint256 id);\r\n    event CreateUser(address userAddress);\r\n    event CreateProcess(address processContractAddress);\r\n    event AssignProcess(uint256 project, address processContractAddress);\r\n    event AssignClient(uint256 project, address clientAddress);\r\n    event ToggleProjectStatus(uint256 id, State newState);\r\n    event ToggleUserStatus(address userAddress, State newState);\r\n\r\n    modifier onlyUser() {\r\n        require(\r\n            _user[msg.sender].status == State.Created,\r\n            'Sender is not whitelisted'\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(string memory _name) public {\r\n        // Creates the admin _user, similar to an owner\r\n        _user[msg.sender] = User(State.Created, Type.Admin, _name);\r\n        _users.push(msg.sender);\r\n    }\r\n\r\n    /// @notice Creates a new project\r\n    /// @param _id Id of a new project\r\n    /// @param _title Title of new project\r\n    /// @param _purchaseOrder Purchase Order Id of project\r\n    function createProject(\r\n        uint256 _id,\r\n        string calldata _title,\r\n        string calldata _purchaseOrder\r\n    ) external onlyOwner {\r\n        require(\r\n            _project[_id].status == State.Null,\r\n            'Project already created or closed'\r\n        );\r\n\r\n        address[] memory processContracts = new address[](0);\r\n        _project[_id] = Project(\r\n            State.Created,\r\n            address(0),\r\n            _title,\r\n            _purchaseOrder,\r\n            processContracts\r\n        );\r\n        projectsArray.push(_id);\r\n\r\n        emit CreateProject(_id);\r\n    }\r\n\r\n    function assignClient(uint256 _id, address _client) external onlyOwner {\r\n        projectsByAddress[_client].push(_id);\r\n        _project[_id].clientAddress = _client;\r\n\r\n        emit AssignClient(_id, _client);\r\n    }\r\n\r\n    /// @notice Creates a new _user\r\n    /// @param _type Type of _user\r\n    /// @param _address Address of _user\r\n    /// @param _name Name of _user\r\n    function createUser(\r\n        Type _type,\r\n        address _address,\r\n        string calldata _name\r\n    ) external onlyOwner {\r\n        _user[_address] = User(State.Created, _type, _name);\r\n        _users.push(_address);\r\n\r\n        emit CreateUser(_address);\r\n    }\r\n\r\n    /// @notice Toggles a _user status\r\n    /// @param _address Address of _user to be toggled\r\n    function toggleUserStatus(address _address) external onlyOwner {\r\n        require(_user[_address].status != State.Null, 'User does not exist');\r\n\r\n        if (_user[_address].status == State.Created)\r\n            _user[_address].status = State.Closed;\r\n        else _user[_address].status = State.Created;\r\n\r\n        emit ToggleUserStatus(_address, _user[_address].status);\r\n    }\r\n\r\n    /// @notice Creates a new process and deploys contract\r\n    /// @param _supplier Supplier Address\r\n    /// @param _processName Name of supplier of process\r\n    /// @param _processName Name of supplier of process\r\n    function createProcess(address _supplier, string calldata _processName)\r\n        external\r\n        onlyOwner\r\n    {\r\n        address processContractAddress = address(\r\n            new Process(_supplier, _processName, owner())\r\n        );\r\n        processesByAddress[_supplier].push(processContractAddress);\r\n        processContractsArray.push(processContractAddress);\r\n\r\n        emit CreateProcess(processContractAddress);\r\n    }\r\n\r\n    /// @notice Adds a process address to a specific project\r\n    /// @param _id The id of a project\r\n    /// @param _processContract The address of a process contract\r\n    function addProcessToProject(uint256 _id, address _processContract)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _project[_id].status == State.Created,\r\n            'Project does not exist or is closed'\r\n        );\r\n\r\n        _project[_id].processContracts.push(_processContract);\r\n\r\n        emit AssignProcess(_id, _processContract);\r\n    }\r\n\r\n    /// @notice Toggles a project status\r\n    /// @param _id The id of a project\r\n    function toggleProjectStatus(uint256 _id) external onlyOwner {\r\n        require(_project[_id].status != State.Null, 'Project does not exist');\r\n\r\n        if (_project[_id].status == State.Created)\r\n            _project[_id].status = State.Closed;\r\n        else _project[_id].status = State.Created;\r\n\r\n        emit ToggleProjectStatus(_id, _project[_id].status);\r\n    }\r\n\r\n    /// @notice Returns specific information about one _user\r\n    /// @param _address User Address\r\n    /// @return Type User Type (supplier or client)\r\n    /// @return string Name of _user\r\n    function getUser(address _address)\r\n        external\r\n        view\r\n        onlyUser\r\n        returns (\r\n            State,\r\n            Type,\r\n            string memory,\r\n            address\r\n        )\r\n    {\r\n        return (\r\n            _user[_address].status,\r\n            _user[_address].userType,\r\n            _user[_address].name,\r\n            _address\r\n        );\r\n    }\r\n\r\n    /// @notice Returns all saved _users\r\n    /// @return address[] Returns array of all created _users\r\n    function getAllUsers() external view onlyOwner returns (address[] memory) {\r\n        return _users;\r\n    }\r\n\r\n    /// @notice Returns all processes\r\n    /// @return address[] Array of all process contracts\r\n    function getProcessContractsByProject(uint256 _id)\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        require(\r\n            _project[_id].clientAddress == msg.sender || msg.sender == owner(),\r\n            'Project and Client do not match'\r\n        );\r\n        return _project[_id].processContracts;\r\n    }\r\n\r\n    /// @notice Returns processes assigned to a supplier\r\n    /// @return address[] Array of process contract addresses specified to a supplier\r\n    function getProcessesByAddress() external view returns (address[] memory) {\r\n        if (msg.sender == owner()) {\r\n            return processContractsArray;\r\n        } else {\r\n            return (processesByAddress[msg.sender]);\r\n        }\r\n    }\r\n\r\n    /// @notice Returns projects assigned to a client\r\n    /// @return uint256[] Array of projects ids specified to a client\r\n    function getProjectsByAddress() external view returns (uint256[] memory) {\r\n        if (msg.sender == owner()) {\r\n            return projectsArray;\r\n        } else {\r\n            return (projectsByAddress[msg.sender]);\r\n        }\r\n    }\r\n\r\n    /// @notice Returns details of a project id\r\n    /// @param _id The id of the project\r\n    /// @return status Current State of project\r\n    /// @return address Client assigned to project\r\n    /// @return string Title of project\r\n    /// @return string Purchase order of project\r\n    /// @return address[] Array of process contract addresses assigned to project\r\n    function getProjectDetails(uint256 _id)\r\n        external\r\n        view\r\n        returns (\r\n            State,\r\n            uint256,\r\n            address,\r\n            string memory,\r\n            string memory,\r\n            address[] memory\r\n        )\r\n    {\r\n        require(\r\n            msg.sender == _project[_id].clientAddress || msg.sender == owner(),\r\n            'User has to be assigned client or owner'\r\n        );\r\n        return (\r\n            _project[_id].status,\r\n            _id,\r\n            _project[_id].clientAddress,\r\n            _project[_id].title,\r\n            _project[_id].purchaseOrder,\r\n            _project[_id].processContracts\r\n        );\r\n    }\r\n}\r\n"
    },
    "src/contracts/Process.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.11;\r\n\r\n/// @title Process Contract\r\n/// @author Sebastian A. Martinez\r\n/// @notice This contract is responsible for each process and its corresponding documents\r\ncontract Process {\r\n    string private _processName;\r\n    address private _supplierAddress;\r\n    address private _owner;\r\n\r\n    struct Document {\r\n        string name;\r\n        string latitude;\r\n        string longitude;\r\n        uint256 mineTime;\r\n        string comment;\r\n    }\r\n\r\n    bytes32[] public allDocuments;\r\n    mapping(bytes32 => Document) private _document;\r\n\r\n    event AddDocument(bytes32 hash);\r\n\r\n    modifier onlySupplier() {\r\n        require(\r\n            msg.sender == _supplierAddress,\r\n            'Sender is not supplier of project'\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _supplier,\r\n        string memory _name,\r\n        address _ownerAddress\r\n    ) public {\r\n        _supplierAddress = _supplier;\r\n        _processName = _name;\r\n        _owner = _ownerAddress;\r\n    }\r\n\r\n    /// @notice Creates a new document\r\n    /// @param _name Name of new document\r\n    /// @param _hash Hash of document\r\n    /// @param _latitude Latitude\r\n    /// @param _longitude Longitude\r\n    /// @param _comment Comment\r\n    function addDocument(\r\n        string calldata _name,\r\n        bytes32 _hash,\r\n        string calldata _latitude,\r\n        string calldata _longitude,\r\n        string calldata _comment\r\n    ) external onlySupplier() {\r\n        require(_document[_hash].mineTime == 0, 'Document already created');\r\n\r\n        _document[_hash] = Document(\r\n            _name,\r\n            _latitude,\r\n            _longitude,\r\n            now, //solhint-disable-line not-rely-on-time\r\n            _comment\r\n        );\r\n        allDocuments.push(_hash);\r\n\r\n        emit AddDocument(_hash);\r\n    }\r\n\r\n    /// @notice Gets document metadata by hash\r\n    /// @param _hash Hash of document\r\n    /// @return string Name of document\r\n    /// @return string Latitude\r\n    /// @return string Longitude\r\n    /// @return uint256 mineTime Moment the transaction got mined\r\n    /// @return string Comment\r\n    function getDocument(bytes32 _hash)\r\n        external\r\n        view\r\n        returns (\r\n            string memory,\r\n            bytes32,\r\n            string memory,\r\n            string memory,\r\n            uint256,\r\n            string memory\r\n        )\r\n    {\r\n        require(_document[_hash].mineTime != 0, 'Document does not exist');\r\n        return (\r\n            _document[_hash].name,\r\n            _hash,\r\n            _document[_hash].latitude,\r\n            _document[_hash].longitude,\r\n            _document[_hash].mineTime,\r\n            _document[_hash].comment\r\n        );\r\n    }\r\n\r\n    /// @notice Gets details about this contract\r\n    /// @return address Address of supplier of this process\r\n    /// @return string Name of process\r\n    /// @return bytes32[] Array of all document hashes in this process\r\n    /// @return address Address of contract\r\n    function getDetails()\r\n        external\r\n        view\r\n        returns (\r\n            address,\r\n            string memory,\r\n            bytes32[] memory,\r\n            address\r\n        )\r\n    {\r\n        return (_supplierAddress, _processName, allDocuments, address(this));\r\n    }\r\n}\r\n"
    },
    "src/contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.11;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, 'Ownable: caller is not the owner');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            'Ownable: new owner is the zero address'\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}